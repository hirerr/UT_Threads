                        +--------------------+
                        |        CS 439      |
                        | PROJECT 1: THREADS |
                        |   DESIGN DOCUMENT  |
                        +--------------------+


The questions in this design document should reflect the design of the code you
wrote for the project.  Your grade will reflect both the quality of your answer
in this document and the quality of the design implementation in your code.  You
may receive partial credit for answering questions for parts of the project that
you did not get to implement, but you must indicate in your answer that there is
no corresponding implementation, or you will not receive any credit.

For each question, you should include both the name of the file(s), function 
name(s), and the line numbers where the relevant code may be found---both the 
code that answers the question directly and any function that you refer to in 
your answer.

These design documents will be completed and submitted as a group.  Please use 
this document as a guide for design and discuss the questions and their 
potential answers prior to beginning implementation.

When you have completed your design document, submit it to the Canvas 
assignment Project 1 Design and Documentation.   

***Your submission must be a text file and each line must not extend past 80 
characters.  In addition, your submission must contain all of the original 
material and not exceed 15,500 characters.  The character count will be 
measured using the Linux command wc.  (Note that rtf files are NOT text files.)

---- Team Information  ----

>> Fill your names, UT EIDs, CS logins, email addresses, and unique numbers:

Name1: Tao Wan
EID1: tlw3595
CS login: taowan
Email: twanslc@utexas.edu
Unique Number: 54895

Name2: Samhith Konyala
EID2: SK62423
CS login: Skon49
Email: Samhith.konyala@utexas.edu
Unique Number: 54895

Name3: Rohan Ralli
EID3: rr54555
CS login: ralli66
Email: rohanralli@utexas.edu
Unique Number: 54880

Slip days used: 0




---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission or notes for the
>> TAs,  please give them here.
>>


>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

    https://www.geeksforgeeks.org/


>> Please paste a link to your GitLab repo below.
>>



                             ALARM CLOCK
                             ===========


---- DATA STRUCTURES ----


>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', â€˜#defineâ€™, or
>> enumeration that was necessary for your implementation of alarm
>> clock.  Identify the purpose of each in 25 words or less.
>>

struct thread {
    struct list_elem sleep_elem; 
    int64_t wake_tick;    
    struct semaphore sema;           
}
We added sleep_elem in struct thread to keep the thread's
position within the sleep list. We used wake_tick to keep
track of when a thread will wake up if it is sleeping.
We used a semaphore to utilize sema_up and sema_down to handle
blocking and unblocking the thread for sleeping and waking up.

static struct list sleep_list;
This list in timer.c keeps track of all threads sleeping
currently, it is sorted by the thread's wake ticks for efficiency.

bool compare_wake_tick (const struct list_elem *a, const struct list_elem *b)
This method defines the comparison of two threads in the sleep list
by comparing their wake_ticks, helps us with efficiency.



---- ALGORITHMS ----


>> A2: Briefly describe what happens when a thread calls timer_sleep(),
>> including the steps necessary to wake a thread (hint: timer_interrupt).
>>

When a thread calls timer sleep, the thread updates its wake_tick based
on the ticks and the current timer_ticks(). Then, it inserts itself list_insert_ordered
on the sleep list and then sema_down and blocks itself. On timer_interrupt(),
we keep checking elements in the sleep list (sorted by wake ticks) and pop the
front element if its wake_tick is <= the current tick. On each element we pop,
we call sema_up on the threads semaphore to wake it up and push it on the ready list. 
Once the top element in the list has a wake_tick greater than the current ticks or 
there are no more elements in the sleep list, we exit the loop.


>> A3: What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?  
>>
We reduced time by using a sleep list sorted by priority of wake ticks (lower the wake-ticks, the higher the priority).  
This reduces the time finding the sleeping thread to O(1) as we can just keep viewing the first thread on the list to see if 
it needs to wake up. If it is then we pop, and if not the handler moves on as the thread is sorted by priority.


---- SYNCHRONIZATION ----


>> A4: How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?  Describe the race conditions.
>>
A race condition would occur in timer_sleep() when multiple threads are trying to call it. 
This would lead them both trying to insert into the sleep list concurrently. Since pointers are involved, 
switching threads and operations in the middle of the method could lead to the sleep list becoming corrupted. 
We avoid this by disabling interrupts in timer_sleep(), ensuring that only one thread can modify the sleep list at a time.


>> A5: How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?  Describe the race conditions.
>>
If the timer interrupt occurs during timer_sleep(), this could cause
race conditions because timer interrupt views and possibly changes the
sleep list. If timer interrupt does this while timer_sleep() is trying to
add to the list, this can cause a corrupted list or an inconsistent traversal
of the list that skips the currently being added thread, putting it to sleep
forever. Another potential issue is if the timer ticks right in between when
we are updating the thread's wake_tick, incorrectly setting the wake_tick.
We handle both of these conditions by disabling interrupts so all interrupts
happen sequentially, not concurrently, leading to consistent states.


---- RATIONALE ----


>> A6: Why did you choose this design?  In what ways is it superior to
>> another design you considered?  Be certain to compare between two
>> working designs.
>>
We used this design as it was the most efficient and correct way for 
a thread to sleep and wake up. We first implemented the use of the all_list 
to wake up the threads instead of the sleep_list. This was very inefficient 
and not correct as it would wake up threads under locks and go through every thread 
in the list (both unblocked and locked). The sorted sleeping list is more efficient than 
the unsorted one as the order to wake it up is O(1). Although the inserting is O(N),
timer_interrupt is called a lot more than timer_sleep so ultimately the approach is
more efficient.




                         PRIORITY SCHEDULING
                         ===================


---- DATA STRUCTURES ----


>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', â€˜#defineâ€™, or
>> enumeration that was necessary for your implementation of priority
>> scheduling and priority donation.  
>> Identify the purpose of each in 25 words or less.
>>

bool compare_priority (const struct list_elem *a, const struct list_elem *b, void *aux UNUSED);
Method used to order the list of threads based on their priority element. (thread.c)

void thread_update_priority(struct thread *t, int new_priority);
Method used to reset the place of a thread in the ready queue after its priority has been changed. (thread.c)

struct semaphore sema; 
Semaphore for thread blocking and waking (struct thread, thread.h)

int base_priority;
Base priority before donations for a thread (struct thread, thread.h)

struct list locks_held;
List of locks held by the thread (struct thread, thread.h)

struct lock *lock_waiting;
Lock that the thread is waiting on, if any (struct thread, thread.h)

struct list_elem elem;
List element for threads holding multiple locks (struct lock, synch.h)

int priority; 
Priority of the waiting thread (struct semaphore_elem, synch.c)

bool compare_waiter_priority (const struct list_elem *a, const struct list_elem *b, void *aux UNUSED);
Method used to order the list of a conditional variable’s queue waiters (synch.c)


---- ALGORITHMS ----


>> B2: How do you ensure that the highest priority thread waiting for
>> a lock, semaphore, or condition variable wakes up first?  
>> Explain for all three.
>>
For our implementation, the case for a lock and semaphore is intertwined, 
as our lock uses a binary semaphore to prevent race conditions. When a 
lock is acquired, we call sema_down to decrement the sema variable and if 
the lock is already acquired, we insert the current thread based on priority
into the semaphore’s waiters list and block the thread. When a lock is released,
we call sema_up to give up the lock. Within sema_up, we disable interrupts and 
then check the lock’s semaphore waiters list. If it’s not empty, we re-sort the 
list based on priority (as priorities could have changed during donation) and 
unblock the highest priority thread at the front of the list to wake it up, inserting 
it into the ready queue based on priority. If needed, we yield the CPU to that thread 
if its priority is higher than our current thread. Our condition variable case also 
intertwines with semaphores. Each condition variable has a list of waiters, sorted by priority. 
Cond_wait inserts a waiter into the waiters list based on priority. Each waiter has a binary 
semaphore to block the current thread in cond_wait(sema_down) as well as unblock/wake(sema_up) 
its associated thread when the cond’s highest priority waiter is chosen from its waiters list 
in cond_signal.


>> B3: Describe the sequence of events when a call to lock_acquire()
>> causes a priority donation.  How is nested donation handled?
>>
Priority donation is needed when a higher priority thread is blocked 
waiting for a lock held by a lower priority thread. In lock_acquire, 
if there’s already a thread on the lock,we use a while loop set on the
condition to run while the current holder of the lock is not null. We
set the current thread’s lock_waiting element (which tracks the lock 
it’s waiting on) to this lock. The loop checks if the current holder’s
priority is less than the current thread’s priority, in which case 
the current holder’s priority is updated. (Using thread_update_priority, 
its place in the ready queue is updated as well.) We then check if the 
current holder itself is waiting for a lock (using lock_waiting), in which
case we update the current holder tracker to that lock’s holder, and continue
this loop until all nested donations necessary have been given. If the 
current holder isn’t waiting for a lock, then the current holder is set 
to null to stop the loop.


>> B4: Describe the sequence of events when lock_release() is called
>> on a lock on which a higher-priority thread is waiting.  What happens to
>> the priority of the thread releasing the lock?
>>
When lock_release is called, sema_up is used on the lock’s semaphore to free 
it up (where the highest priority thread waiting for the lock is chosen to be 
unblocked onto the ready queue and yielded to if necessary), and the lock is 
removed from the lock list of the thread releasing the lock. The thread releasing
the lock (now that its donation priority for this lock has been revoked) then 
iterates through all the locks in its lock list and the threads in those locks’ 
semaphore.waiters, comparing its priority with each one to eventually assign the 
highest of those priorities to the priority of the thread releasing the lock 
(thread_set_priority_donate is used here to assign the new priority and yield 
in case this thread no longer has the highest priority). The lock’s holder element
is also set to null to release the lock.

---- SYNCHRONIZATION ----


>> B5: Describe a potential race in thread_set_priority() and explain
>> how your implementation avoids it.  Can you use a lock to avoid
>> this race?  Defend your answer.
>>

The race condition is that the current thread doesn't hold any locks currently, so it
enters the if statement to change its actual priority (not just base). Then,
an interrupt happens and thread gains a lock with donated priority. However,
once it returns from interrupt it will still change its actual priority since its already
in the if statement. This will lead to the donated priority being wiped and priority inversion.
We fixed this by simply disabling interrupts so that the priority changing 
and preempting will happen atomically, maintaining consistent states and preventing 
external interrupts from destroying our sequence.

---- RATIONALE ----


>> B6: Why did you choose this design for your priority scheduling and
>> donation?  In what ways is it superior to another design you considered?
>> Please make certain you discuss both priority scheduling and donation, and
>> be certain to compare against working designs.
>>

For priority scheduling we just kept the ready_list and used list_insert_ordered
and sometimes sorting the list to maintain priority. We also checked for preemption
in thread_tick() and when we change the priority to ensure we are always running the 
highest priority thread. This could have been also implemented with a heap/priority queue
but that would add much more complexity and would be difficult to remove from for updating priority
and blocking. Additionally, the number of threads isn't extremely large for this project
so binary heaps would add unnecessary complexity.

For donation, we included a base_priority and the current priority to maintain priorities
as well as a list of locks held for each thread to help calculate its current priority on release
by viewing the top waiter of all the locks held. We also created a lock_waiting member in threads, 
allowing for nested donation in a singly linked list like structure where each thread holds its next thread 
its waiting for with its lock_waiting->holder. An alternative we thought of was to include a priority for each lock
and then insert them sorted each time so then we can just see the top priority of the locks held upon release.
However, this didn't really add any efficiency as insert sorted is average O(n) and created a more complicated design.
For the donation, we also thought about using a global structure of a 2d list of locks that keeps
track of which locks depends on others, but that would add much more complexity compared to the linked
list approach.


                           SURVEY QUESTIONS
                           ================


Answering these questions is optional, but it will help us improve the
course in future semesters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the semester.


>> In your opinion, was this assignment, or any one of the two problems
>> in it, too easy or too hard?  Did it take too long or too little time?
>>


>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?
>>


>> Is there some particular fact or hint we should give students in
>> future semesters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?
>>


>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future semesters or the remaining projects?
>>


>> Any other comments?
>>